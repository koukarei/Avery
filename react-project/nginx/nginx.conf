upstream backend {
    server backend:8000;
}

server {
    listen 80;

    # Proxy API and WebSocket requests to the backend (internal port 8000)
    # resolver is needed if upstream returns absolute redirects with hostnames
    # Using a DNS resolver inside the container; default Google DNS is a safe fallback.
    resolver 8.8.8.8 valid=30s ipv6=off;

    location /sqlapp2/ {
        proxy_pass http://backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        # Preserve original host and scheme so backend can generate correct redirects
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Host $server_name;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Port $server_port;
        proxy_intercept_errors on;
        proxy_set_header Cookie $http_cookie;
        proxy_redirect / /;
        # Intercept redirect responses so NGINX can follow them internally.
        # Include 303 (See Other) as well.
        error_page 301 302 303 307 308 = @handle_redirect;
    }

    # Increase client_max_body_size for image uploads
    location /sqlapp2/leaderboards/image {
        proxy_pass http://backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # Important for file uploads
        client_max_body_size 10M;
        proxy_request_buffering off;
    }

    # --- Frontend-prefixed routes: expose the same backend endpoints under
    # /avery_analytics/sqlapp2/... but forward to the backend without
    # the frontend prefix. This strips the `avery_analytics` segment when
    # proxying so backend still sees /sqlapp2/...
    location /avery_analytics/sqlapp2/ {
        proxy_pass http://backend/sqlapp2/;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        # Preserve original host and scheme so backend can generate correct redirects
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Host $server_name;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Port $server_port;
        proxy_intercept_errors on;
        proxy_set_header Cookie $http_cookie;
        proxy_redirect / /;
        # Intercept redirect responses so NGINX can follow them internally.
        error_page 301 302 303 307 308 = @handle_redirect;
    }

    # Frontend-prefixed upload path for leaderboard images
    location /avery_analytics/sqlapp2/leaderboards/image {
        proxy_pass http://backend/sqlapp2/leaderboards/image;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # Important for file uploads
        client_max_body_size 10M;
        proxy_request_buffering off;
    }

    location / {
        root   /usr/share/nginx/html;
        index  index.html index.htm;
        try_files $uri $uri/ /index.html;
    }

    location /avery_analytics/assets/ {
        rewrite ^/avery_analytics(/.*)$ $1 last;
    }
    
    # Proxy LTI login path to the Gradio backend that handles LTI
    location = /avery_analytics/lti/login {
        proxy_pass http://backend/sqlapp2/lti/login; # adjust host/port/service name
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_buffering off;
    }

    # Convert upstream Location header (which may be relative) into an absolute URL
    # and internally proxy_pass to it so nginx follows the redirect.
    location @handle_redirect {
        # the raw Location header from the upstream
        set $upstream_location $upstream_http_location;
        # Initialize
        set $saved_redirect_location "";

        # 1) Absolute or scheme-relative redirects: extract the path and
        # always proxy to the internal backend using that path. This ensures
        # we never attempt to resolve 'localhost' or the client's host from
        # inside the container.
        set $redirect_path "";
        if ($upstream_location ~* "^https?://[^/]+(/.*)") {
            set $redirect_path "$1";
            set $saved_redirect_location "http://backend$redirect_path";
        }
        if ($upstream_location ~* "^//[^/]+(/.*)") {
            set $redirect_path "$1";
            set $saved_redirect_location "http://backend$redirect_path";
        }

        # 3) Root-relative URLs: start with /
        # Use the backend upstream name so the request is proxied internally to the backend
        # instead of resolving the client hostname (e.g. localhost) inside the container.
        if ($upstream_location ~ "^/") {
            set $saved_redirect_location "http://backend$upstream_location";
        }

        # 4) Relative URLs (no leading /): resolve relative to the current request path ($uri)
        # Normalize the request path to ensure a single trailing slash in $base_uri,
        # then append the relative upstream_location. This avoids nested 'if' blocks.
        set $base_uri $uri;
        if ($base_uri !~ "/$") {
            set $base_uri "$base_uri/";
        }

        if ($upstream_location !~* "^(https?://|//|/)") {
            set $saved_redirect_location "http://backend$base_uri$upstream_location";
        }

        # 5) Upstream redirect relative URL '/sqlapp2/ ..'
        # base url is backend, so we need to replace it with frontend path
        if ($upstream_location ~ "^/sqlapp2/(.*)") {
            set $saved_redirect_location "/avery_analytics/$1";
        }

        # Fallback: if empty or unknown, return 502
        if ($saved_redirect_location = "") {
            return 502;
        }

        # Determine Host header for the proxied follow-up request.
        # Default to the original $host, but if the target is the internal backend
        # use 'backend' so the backend receives the expected Host header and does
        # not emit redirects back to 'localhost'.
        set $pass_host $host;
        if ($saved_redirect_location ~* "^http://backend") {
            set $pass_host "backend";
        }

        # proxy_pass to the computed absolute location. Use resolver for hostnames.
        proxy_pass $saved_redirect_location;
        proxy_set_header Host $pass_host;


        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Host $server_name;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Port $server_port;

        # allow backend Set-Cookie to pass through to the browser
        proxy_pass_header Set-Cookie;

        # rewrite cookie Path from backend -> frontend so browser sends cookies on frontend path
        proxy_cookie_path /sqlapp2/ /avery_analytics/;

        # ensure client receives backend 3xx + Set-Cookie (do not intercept)
        proxy_intercept_errors off;
        

        # forward client cookies to backend if needed
        proxy_set_header Cookie $http_cookie;
    }

    error_page   500 502 503 504  /50x.html;

    location = /50x.html {
        root   /usr/share/nginx/html;
    }
}
